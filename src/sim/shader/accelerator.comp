#version 460

/*
 * This shader implements movement on an externally provided path along waypoints.
 * Supports gpu accelerated collision and connectivity detection. 
 */

layout (local_size_x = 32) in;

// Per shader invocation parameter
layout(push_constant) uniform Parameter {
    uint pass;
    float timeIncrement;
    uint interfaceCollisionSetOldOffset; // Points at start of previous tick collisions
    uint interfaceCollisionSetNewOffset; // Points at start of current tick collisions
} parameter;

// ------------------------------------------------------------------------------------
// Entities
// ------------------------------------------------------------------------------------

struct EntityDescriptor {
    vec4 color;
    vec2 pos;
    uint targetWaypointOffset;
    uint PADDING;
};

layout(set = 0, binding = 0) buffer bufEntity { EntityDescriptor entities[]; };

// ------------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------------

struct ConstantsDescriptor {
	float worldSizeX;
	float worldSizeY;

	uint nodeCount;
	uint entityCount;
	uint maxDepth;
    uint entityNodeCap;

    float interfaceRange;

    uint waypointBufferSize; // Number of waypoints per entity
    uint waypointBufferThreshold;

    uint maxInterfaceCollisionListCount;
    uint maxInterfaceCollisionSetCount;
    uint maxLinkEventCount;
};

layout(set = 0, binding = 1) buffer readonly bufConstants { ConstantsDescriptor constants[]; };

// ------------------------------------------------------------------------------------
// Waypoints
// ------------------------------------------------------------------------------------

struct WaypointDescriptor {
    vec2 pos;
    float speed;
    float PADDING;
};

layout(set = 0, binding = 2, std430) buffer readonly bufWaypoints { WaypointDescriptor waypoints[]; };


precision highp float;
precision highp int;

// ------------------------------------------------------------------------------------
// Quad Tree
// ------------------------------------------------------------------------------------
uint TYPE_INVALID = 0;
uint TYPE_NODE = 1;
uint TYPE_ENTITY = 2;

struct QuadTreeNodeDescriptor {
    int acquireLock;
    int writeLock;
    uint next;

    float offsetX;
    float offsetY;
    float width;
    float height;

    uint contentType;
    uint entityCount;
    uint first; // references a QuadTreeEntityDescriptor AND a EntityDescriptor

    uint prevNodeIndex; // aka parent node index

    uint nextTL;
    uint nextTR;
    uint nextBL;
    uint nextBR;

    uint padding;
};

struct QuadTreeEntityDescriptor {
    uint nodeIndex; // references a QuadTreeNodeDescriptor

    uint typeNext; // Caution: typeNext is not 100% reliable, there are bugs :(
                   //          Try to use a nodes entity count wherever possible
    uint next; // references a QuadTreeEntityDescriptor AND a EntityDescriptor

    uint typePrev;
    uint prev; // references a QuadTreeEntityDescriptor AND a EntityDescriptor
};

// TODO add memory qualifiers: https://www.khronos.org/opengl/wiki/Shader_Storage_Buffer_Object
layout(set = 0, binding = 3, std430) buffer coherent bufQuadTreeNodes { QuadTreeNodeDescriptor quadTreeNodes[]; };
layout(set = 0, binding = 4, std430) buffer coherent bufQuadTreeEntities { QuadTreeEntityDescriptor quadTreeEntities[]; };
/**
 * [0]: Lock
 * [1]: Next free hint
 * [2... (nodeCount + 2)]: Node locks
 **/
layout(set = 0, binding = 5, std430) buffer coherent bufQuadTreeNodeStatus { uint quadTreeNodeUsedStatus[]; };

// ------------------------------------------------------------------------------------
// Metadata
// ------------------------------------------------------------------------------------

struct IDPairDescriptor {
    uint ID0;
    uint ID1;
};

struct MetadataDescriptor {
    uint waypointRequestCount;
    uint interfaceCollisionListCount;
    uint interfaceCollisionSetCount;
    uint interfaceLinkUpListCount;
    uint interfaceLinkDownListCount;
    uint debug;
};

layout(set = 0, binding = 6, std430) buffer coherent bufMetadata { MetadataDescriptor metadata[]; };

// ------------------------------------------------------------------------------------
// Collision Detection
// ------------------------------------------------------------------------------------

layout(set = 0, binding = 7, std430) buffer bufInterfaceCollisionsList { IDPairDescriptor collisionsList[]; };

// ------------------------------------------------------------------------------------
// Events
// ------------------------------------------------------------------------------------

layout(set = 0, binding = 8, std430) buffer bufWaypointRequests { IDPairDescriptor waypointRequests[]; };

// ------------------------------------------------------------------------------------
// Connectivity Detection
// ------------------------------------------------------------------------------------

const uint InterfaceCollisionBlockSize = 63;
struct InterfaceCollisionBlockDescriptor {
    uint offset;
    uint colls[InterfaceCollisionBlockSize];
};

layout(set = 0, binding = 9, std430) buffer bufInterfaceCollisionsSet { InterfaceCollisionBlockDescriptor collisionsSet[]; };

layout(set = 0, binding = 10, std430) buffer bufLinkUpEvents { IDPairDescriptor linkUpEvents[]; };
layout(set = 0, binding = 11, std430) buffer bufLinkDownEvents { IDPairDescriptor linkDownEvents[]; };

// ------------------------------------------------------------------------------------
// Functions
// ------------------------------------------------------------------------------------

void quad_tree_lock_node_read(uint nodeIndex) {
    while(atomicCompSwap(quadTreeNodes[nodeIndex].acquireLock, 0, 1) != 0) {}

    // Prevent from reading, when we are currently writing:
    while(quadTreeNodes[nodeIndex].writeLock != 0) {}
    atomicAdd(quadTreeNodes[nodeIndex].readerLock, 1);

    atomicExchange(quadTreeNodes[nodeIndex].acquireLock, 0);
    memoryBarrierBuffer();
}

void quad_tree_unlock_node_read(uint nodeIndex) {
    atomicAdd(quadTreeNodes[nodeIndex].readerLock, -1);
    memoryBarrierBuffer();
}

/**
 * Locks read and write for the given nodeIndex.
 **/
void quad_tree_lock_node_read_write(uint nodeIndex) {
    while(atomicCompSwap(quadTreeNodes[nodeIndex].acquireLock, 0, 1) != 0) {}

    // Wait until all others stopped reading:
    while(atomicCompSwap(quadTreeNodes[nodeIndex].readerLock, 0, 1) != 0) {}
    while(atomicCompSwap(quadTreeNodes[nodeIndex].writeLock, 0, 1) != 0) {}

    atomicExchange(quadTreeNodes[nodeIndex].acquireLock, 0);
    memoryBarrierBuffer();
}

void quad_tree_unlock_node_write(uint nodeIndex) {
    atomicExchange(quadTreeNodes[nodeIndex].writeLock, 0);
    memoryBarrierBuffer();
}

void quad_tree_init_entity(uint index, uint typeNext, uint next, uint nodeIndex) {
    quadTreeEntities[index].typeNext = typeNext;
    quadTreeEntities[index].next = next;
    quadTreeEntities[index].typePrev = TYPE_INVALID;
    quadTreeEntities[index].prev = 0;
    quadTreeEntities[index].nodeIndex = nodeIndex;
}

void quad_tree_append_entity(uint nodeIndex, uint index) {
    if(quadTreeNodes[nodeIndex].entityCount <= 0) {
        quadTreeNodes[nodeIndex].first = index;
        quad_tree_init_entity(index, TYPE_INVALID, 0, nodeIndex);
    }
    else {
        // Add in front:
        uint oldFirstIndex = quadTreeNodes[nodeIndex].first;
        quad_tree_init_entity(index, TYPE_ENTITY, oldFirstIndex, nodeIndex);

        quadTreeEntities[oldFirstIndex].typePrev = TYPE_ENTITY;
        quadTreeEntities[oldFirstIndex].prev = index;

        quadTreeNodes[nodeIndex].first = index;
    }
    quadTreeNodes[nodeIndex].entityCount++;
    memoryBarrierBuffer();
}

/**
 * Moves up the quad tree and unlocks all nodes from reading again.
 **/
void quad_tree_unlock_nodes_read(uint nodeIndex) {
    while(quadTreeNodes[nodeIndex].prevNodeIndex != nodeIndex) {
        uint oldNodeIndex = nodeIndex;
        nodeIndex = quadTreeNodes[nodeIndex].prevNodeIndex;
        quad_tree_unlock_node_read(oldNodeIndex);
    }
    // Unlock the first node:
    quad_tree_unlock_node_read(nodeIndex);
}

uint quad_tree_get_free_node_index() {
    uint index = 0;
    uint i = quadTreeNodeUsedStatus[1];
    while(index <= 0) {
        if(quadTreeNodeUsedStatus[i] == 0) {
            quadTreeNodeUsedStatus[i] = 1;
            index = i - 2;
        }

        i++;
        if(i >= (constants[0].nodeCount + 2)) {
            i = 2;
        }
    }
    quadTreeNodeUsedStatus[1] = i;
    return index;
}

uvec4 quad_tree_get_free_node_indices() {
    uvec4 indices = uvec4(0);
    while(atomicCompSwap(quadTreeNodeUsedStatus[0], 0, 1) != 0) {}

    indices.x = quad_tree_get_free_node_index();
    indices.y = quad_tree_get_free_node_index();
    indices.z = quad_tree_get_free_node_index();
    indices.w = quad_tree_get_free_node_index();

    memoryBarrierBuffer();
    atomicExchange(quadTreeNodeUsedStatus[0], 0);

    return indices;
}

void quad_tree_free_node_indices(uvec4 indices) {
    while (atomicCompSwap(quadTreeNodeUsedStatus[0], 0, 1) != 0) {}

    quadTreeNodeUsedStatus[indices.x + 2] = 0;
    quadTreeNodeUsedStatus[indices.y + 2] = 0;
    quadTreeNodeUsedStatus[indices.z + 2] = 0;
    quadTreeNodeUsedStatus[indices.w + 2] = 0;

    quadTreeNodeUsedStatus[1] = indices.x + 2;

    memoryBarrierBuffer();
    atomicExchange(quadTreeNodeUsedStatus[0], 0);
}

void quad_tree_init_node(uint nodeIndex, uint prevNodeIndex, float offsetX, float offsetY, float width, float height) {
    quadTreeNodes[nodeIndex].acquireLock = 0;
    quadTreeNodes[nodeIndex].writeLock = 0;
    quadTreeNodes[nodeIndex].readerLock = 0;

    quadTreeNodes[nodeIndex].offsetX = offsetX;
    quadTreeNodes[nodeIndex].offsetY = offsetY;
    quadTreeNodes[nodeIndex].width = width;
    quadTreeNodes[nodeIndex].height = height;

    quadTreeNodes[nodeIndex].prevNodeIndex = prevNodeIndex;
    quadTreeNodes[nodeIndex].contentType = TYPE_ENTITY;
    quadTreeNodes[nodeIndex].entityCount = 0;
}

void quad_tree_move_entities(uint nodeIndex) {
    float offsetXNext = quadTreeNodes[nodeIndex].offsetX + (quadTreeNodes[nodeIndex].width / 2);
    float offsetYNext = quadTreeNodes[nodeIndex].offsetY + (quadTreeNodes[nodeIndex].height / 2);

    uint index = quadTreeNodes[nodeIndex].first;
    quadTreeNodes[nodeIndex].first = 0;
    quadTreeNodes[nodeIndex].entityCount = 0;

    bool hasNext = false;
    do {
        uint nextIndex = quadTreeEntities[index].next;
        hasNext = quadTreeEntities[index].typeNext != TYPE_INVALID;
        quadTreeEntities[index].next = 0;
        quadTreeEntities[index].typeNext = TYPE_INVALID;

        vec2 ePos = entities[index].pos;

        uint newNodeIndex = 0;
        // Left:
        if(ePos.x < offsetXNext)  {
            // Top:
            if(ePos.y < offsetYNext) {
                newNodeIndex = quadTreeNodes[nodeIndex].nextTL;
            }
            else {
                newNodeIndex = quadTreeNodes[nodeIndex].nextBL;
            }
        }
        // Right:
        else {
            // Top:
            if(ePos.y < offsetYNext) {
                newNodeIndex = quadTreeNodes[nodeIndex].nextTR;
            }
            else {
                newNodeIndex = quadTreeNodes[nodeIndex].nextBR;
            }
        }
        quad_tree_append_entity(newNodeIndex, index);
        index = nextIndex;
    } while (hasNext);
}

void quad_tree_split_up_node(uint nodeIndex) {
    quadTreeNodes[nodeIndex].contentType = TYPE_NODE;

    uvec4 newNodeIndices = quad_tree_get_free_node_indices();

    float newWidth = quadTreeNodes[nodeIndex].width / 2;
    float newHeight = quadTreeNodes[nodeIndex].height / 2;

    quadTreeNodes[nodeIndex].nextTL = newNodeIndices.x;
    quad_tree_init_node(quadTreeNodes[nodeIndex].nextTL, nodeIndex, quadTreeNodes[nodeIndex].offsetX, quadTreeNodes[nodeIndex].offsetY, newWidth, newHeight);
    quadTreeNodes[nodeIndex].nextTR = newNodeIndices.y;
    quad_tree_init_node(quadTreeNodes[nodeIndex].nextTR, nodeIndex, quadTreeNodes[nodeIndex].offsetX + newWidth, quadTreeNodes[nodeIndex].offsetY, newWidth, newHeight);
    quadTreeNodes[nodeIndex].nextBL = newNodeIndices.z;
    quad_tree_init_node(quadTreeNodes[nodeIndex].nextBL, nodeIndex, quadTreeNodes[nodeIndex].offsetX, quadTreeNodes[nodeIndex].offsetY + newHeight, newWidth, newHeight);
    quadTreeNodes[nodeIndex].nextBR = newNodeIndices.w;
    quad_tree_init_node(quadTreeNodes[nodeIndex].nextBR, nodeIndex, quadTreeNodes[nodeIndex].offsetX + newWidth, quadTreeNodes[nodeIndex].offsetY + newHeight, newWidth, newHeight);

    quad_tree_move_entities(nodeIndex);
    memoryBarrierBuffer();
}

// Returns whether the first entity in the node with <nodeIndex> has 
//  the coordinates <ePos>
bool quad_tree_same_pos_as_first(uint nodeIndex, vec2 ePos) {
    if(quadTreeNodes[nodeIndex].entityCount > 0) {
        uint index = quadTreeNodes[nodeIndex].first;
        return entities[index].pos == ePos;
    }
    return false;
}

void quad_tree_insert(uint index, uint startNodeIndex, uint startNodeDepth) {
    vec2 ePos = entities[index].pos;
    uint curDepth = startNodeDepth;

    uint nodeIndex = startNodeIndex;
    while (true) {
        quad_tree_lock_node_read(nodeIndex);
        float offsetXNext = quadTreeNodes[nodeIndex].offsetX + (quadTreeNodes[nodeIndex].width / 2);
        float offsetYNext = quadTreeNodes[nodeIndex].offsetY + (quadTreeNodes[nodeIndex].height / 2);

        // Go one node deeper:
        if (quadTreeNodes[nodeIndex].contentType == TYPE_NODE) {
            // Left:
            if (ePos.x < offsetXNext) {
                // Top:
                if (ePos.y < offsetYNext) {
                    nodeIndex = quadTreeNodes[nodeIndex].nextTL;
                } else {
                    nodeIndex = quadTreeNodes[nodeIndex].nextBL;
                }
            }
            // Right:
            else {
                // Top:
                if (ePos.y < offsetYNext) {
                    nodeIndex = quadTreeNodes[nodeIndex].nextTR;
                } else {
                    nodeIndex = quadTreeNodes[nodeIndex].nextBR;
                }
            }
            curDepth += 1;
        } else {
            // Prevent a deadlock:
            quad_tree_unlock_node_read(nodeIndex);
            quad_tree_lock_node_read_write(nodeIndex);

            // Check if something has changed in the meantime with the node. Retry...
            if (quadTreeNodes[nodeIndex].contentType == TYPE_NODE) {
                quad_tree_unlock_node_write(nodeIndex);
                quad_tree_unlock_node_read(nodeIndex);
            } else {
                // Insert the entity in case there is space left, we can't go deeper or the entity has the same pos as the first:
                if (quadTreeNodes[nodeIndex].entityCount < constants[0].entityNodeCap || 
                    curDepth >= constants[0].maxDepth || 
                    quad_tree_same_pos_as_first(nodeIndex, ePos))
                {
                    quad_tree_append_entity(nodeIndex, index);
                    memoryBarrierBuffer();
                    quad_tree_unlock_node_write(nodeIndex);
                    break;
                }
                // Split up
                memoryBarrierBuffer();
                quad_tree_split_up_node(nodeIndex);
                quad_tree_unlock_node_write(nodeIndex);
                quad_tree_unlock_node_read(nodeIndex);
            }
        }
        memoryBarrierBuffer();  // Ensure everything is in sync
    }
    // Unlock all nodes again:
    quad_tree_unlock_nodes_read(nodeIndex);
}

bool quad_tree_is_entity_on_node(uint nodeIndex, vec2 ePos) {
    return ePos.x >= quadTreeNodes[nodeIndex].offsetX && 
        ePos.x < (quadTreeNodes[nodeIndex].offsetX + quadTreeNodes[nodeIndex].width) && 
        ePos.y >= quadTreeNodes[nodeIndex].offsetY && 
        ePos.y < (quadTreeNodes[nodeIndex].offsetY + quadTreeNodes[nodeIndex].height);
}

/**
 * Moves down the quad tree and locks all nodes as read, except the last node, which gets locked as write so we can edit it.
 **/
uint quad_tree_lock_for_entity_edit(uint index) {
    vec2 ePos = entities[index].pos;
    uint nodeIndex = 0;
    while (true) {
        quad_tree_lock_node_read(nodeIndex);
        float offsetXNext = quadTreeNodes[nodeIndex].offsetX + (quadTreeNodes[nodeIndex].width / 2);
        float offsetYNext = quadTreeNodes[nodeIndex].offsetY + (quadTreeNodes[nodeIndex].height / 2);

        // Go one node deeper:
        if (quadTreeNodes[nodeIndex].contentType == TYPE_NODE) {
            // Left:
            if (ePos.x < offsetXNext) {
                // Top:
                if (ePos.y < offsetYNext) {
                    nodeIndex = quadTreeNodes[nodeIndex].nextTL;
                } else {
                    nodeIndex = quadTreeNodes[nodeIndex].nextBL;
                }
            }
            // Right:
            else {
                // Top:
                if (ePos.y < offsetYNext) {
                    nodeIndex = quadTreeNodes[nodeIndex].nextTR;
                } else {
                    nodeIndex = quadTreeNodes[nodeIndex].nextBR;
                }
            }
        } else {
            // Prevent a deadlock:
            quad_tree_unlock_node_read(nodeIndex);
            quad_tree_lock_node_read_write(nodeIndex);

            // Check if something has changed in the meantime with the node. Retry...
            if (quadTreeNodes[nodeIndex].contentType == TYPE_NODE) {
                quad_tree_unlock_node_write(nodeIndex);
                quad_tree_unlock_node_read(nodeIndex);
            } else {
                return nodeIndex;
            }
        }
        memoryBarrierBuffer();
    }
}

/**
 * Removes the given entity from its node.
 * Returns true in case it was the last entity on this node.
 **/
bool quad_tree_remove_entity(uint index) {
    uint nodeIndex = quadTreeEntities[index].nodeIndex;
    if (quadTreeNodes[nodeIndex].entityCount <= 1) {
        quadTreeNodes[nodeIndex].first = 0;
        quadTreeNodes[nodeIndex].entityCount = 0;
        return true;
    }

    if (quadTreeNodes[nodeIndex].first == index) {
        quadTreeNodes[nodeIndex].first = quadTreeEntities[index].next;
    }

    if (quadTreeEntities[index].typePrev == TYPE_ENTITY) {
        uint prevIndex = quadTreeEntities[index].prev;
        quadTreeEntities[prevIndex].next = quadTreeEntities[index].next;
        quadTreeEntities[prevIndex].typeNext = quadTreeEntities[index].typeNext;
    }

    if (quadTreeEntities[index].typeNext == TYPE_ENTITY) {
        uint nextIndex = quadTreeEntities[index].next;
        quadTreeEntities[nextIndex].prev = quadTreeEntities[index].prev;
        quadTreeEntities[nextIndex].typePrev = quadTreeEntities[index].typePrev;
    }
    quadTreeEntities[index].typePrev = TYPE_INVALID;
    quadTreeEntities[index].typeNext = TYPE_INVALID;
    quadTreeNodes[nodeIndex].entityCount -= 1;

    return false;
}

bool quad_tree_is_node_empty(uint nodeIndex) {
    return quadTreeNodes[nodeIndex].entityCount <= 0 && 
        quadTreeNodes[nodeIndex].contentType == TYPE_ENTITY;
}

bool quad_tree_try_merging_subnode(uint nodeIndex) {
    if (quadTreeNodes[nodeIndex].contentType != TYPE_NODE) {
        return false;
    }

    if (quad_tree_is_node_empty(quadTreeNodes[nodeIndex].nextTL) && quad_tree_is_node_empty(quadTreeNodes[nodeIndex].nextTR) && quad_tree_is_node_empty(quadTreeNodes[nodeIndex].nextBL) && quad_tree_is_node_empty(quadTreeNodes[nodeIndex].nextBR)) {
        quad_tree_free_node_indices(uvec4(quadTreeNodes[nodeIndex].nextTL, quadTreeNodes[nodeIndex].nextTR, quadTreeNodes[nodeIndex].nextBL, quadTreeNodes[nodeIndex].nextBR));
        quadTreeNodes[nodeIndex].contentType = TYPE_ENTITY;
        return true;
    }
    return false;
}

uint quad_tree_get_cur_depth(uint nodeIndex) {
    uint depth = 1;
    while (quadTreeNodes[nodeIndex].prevNodeIndex != nodeIndex) {
        nodeIndex = quadTreeNodes[nodeIndex].prevNodeIndex;
        depth++;
    }
    return depth;
}

// Update an entities position
//  (and possibly its location in the quadtree as well as the quadtree itself)
void quad_tree_update(uint index, vec2 newPos) {
    uint nodeIndex;
    while (true) {
        nodeIndex = quadTreeEntities[index].nodeIndex;
        quad_tree_lock_node_read(nodeIndex);
        // Make sure our entity is still on the same node when we finally get the lock.
        // Could happen in case the current node got split up in the meantime.
        if (nodeIndex == quadTreeEntities[index].nodeIndex) {
            break;
        }
        quad_tree_unlock_node_read(nodeIndex);
    }

    // Still on the same node, so we do not need to do anything..
    //  except if entity count is above limits (should split node), 
    //  and we have not reached the max depth yet (can split node).
    if (quad_tree_is_entity_on_node(nodeIndex, newPos) &&
        (quadTreeNodes[nodeIndex].entityCount < constants[0].entityNodeCap || 
         quad_tree_get_cur_depth(nodeIndex) >= constants[0].maxDepth)) {
        entities[index].pos = newPos;
        quad_tree_unlock_node_read(nodeIndex);
        return;
    }

    quad_tree_unlock_node_read(nodeIndex);
    nodeIndex = quad_tree_lock_for_entity_edit(index);
    if (quad_tree_remove_entity(index)) {
        // Try merging nodes:
        while (nodeIndex != quadTreeNodes[nodeIndex].prevNodeIndex) {
            quad_tree_unlock_node_write(nodeIndex);
            quad_tree_unlock_node_read(nodeIndex);
            nodeIndex = quadTreeNodes[nodeIndex].prevNodeIndex;

            // Prevent deadlocks:
            quad_tree_unlock_node_read(nodeIndex);
            quad_tree_lock_node_read_write(nodeIndex);

            if (!quad_tree_try_merging_subnode(nodeIndex)) {
                break;
            }
        }
    }
    quad_tree_unlock_node_write(nodeIndex);

    // Update the removed entity position:
    entities[index].pos = newPos;

    // Move up until we reach a node where our entity is on:
    while (!quad_tree_is_entity_on_node(nodeIndex, entities[index].pos)) {
        uint oldNodeIndex = nodeIndex;
        nodeIndex = quadTreeNodes[nodeIndex].prevNodeIndex;
        quad_tree_unlock_node_read(oldNodeIndex);
    }

    // Insert the entity again:
    quad_tree_unlock_node_read(nodeIndex);
    quad_tree_insert(index, nodeIndex, quad_tree_get_cur_depth(nodeIndex));
}

// Forward declarations
void collision_list_add(uint index0, uint index1);
void collision_set_add(uint index0, uint index1);

// Collision detection callback. Called only once per collision pair
void quad_tree_collision(uint index0, uint index1) {
    // Color colliding entities blue
    entities[index0].color = vec4(0, 0, 1, 1);
    entities[index1].color = vec4(0, 0, 1, 1);

    // Note: Each entity only has one interface for now
    //  => just use entity ID as interface ID

    if (parameter.pass == 2) {
        collision_list_add(index0, index1);
    } else {
        collision_set_add(index0, index1);
    }
}

// Returns <true> if the distance between <v1> and <v2> is less than <range>
//  Aka check wether <v1> and <v2> are colliding
bool quad_tree_in_range(vec2 v1, vec2 v2, float range) {
    v1 -= v2;
    return dot(v1, v1) <= range * range;
}

bool quad_tree_is_entity_within_node(uint nodeIndex, vec2 ePos) {
    return quadTreeNodes[nodeIndex].offsetX < (ePos.x - constants[0].interfaceRange)  && 
        (quadTreeNodes[nodeIndex].offsetX + quadTreeNodes[nodeIndex].width) > (ePos.x + constants[0].interfaceRange) && 
        quadTreeNodes[nodeIndex].offsetY < (ePos.y - constants[0].interfaceRange) && 
        (quadTreeNodes[nodeIndex].offsetY + quadTreeNodes[nodeIndex].height) > (ePos.y + constants[0].interfaceRange);
}

bool quad_tree_is_entity_within_node_AABB(uint nodeIndex, vec2 AABBmin, vec2 AABBmax) {
    return quadTreeNodes[nodeIndex].offsetX <= AABBmin.x  && 
        quadTreeNodes[nodeIndex].offsetY <= AABBmin.y && 
        (quadTreeNodes[nodeIndex].offsetX + quadTreeNodes[nodeIndex].width) >= AABBmax.x && 
        (quadTreeNodes[nodeIndex].offsetY + quadTreeNodes[nodeIndex].height) >= AABBmax.y;
}

// Checks if entity <index> collides with any entities on node <nodeIndex>
void quad_tree_check_entity_collisions_on_node(uint index, uint nodeIndex) {
    vec2 ePos = entities[index].pos;

    // Walk linked list
    uint curEntityIndex = quadTreeNodes[nodeIndex].first;
    uint count = quadTreeNodes[nodeIndex].entityCount;
    for (int i=0; i<count; i++) {
        // Prevent checking collision with our self and prevent duplicate entries by checking only for ones where our index is strictly smaller than the other
        if (index < curEntityIndex && quad_tree_in_range(entities[curEntityIndex].pos, ePos, constants[0].interfaceRange)) {
            quad_tree_collision(index, curEntityIndex);
        }

        curEntityIndex = quadTreeEntities[curEntityIndex].next;
    }
}

/**
 * Returns the next (TL -> TR -> BL -> BR -> parent... -> 0) node index while traversing the tree.
 * Steps upwards if necessary (Returns next index from the parent node).
 * Returns 0 if stepping up from root node aka tree has been fully traversed.
 **/
uint quad_tree_step_next_node_index(uint nodeIndex) {
    while (true)
    {
        uint prevNodeIndex = quadTreeNodes[nodeIndex].prevNodeIndex;

        if (quadTreeNodes[prevNodeIndex].nextTL == nodeIndex) {
            return quadTreeNodes[prevNodeIndex].nextTR;
        }

        if (quadTreeNodes[prevNodeIndex].nextTR == nodeIndex) {
            return quadTreeNodes[prevNodeIndex].nextBL;
        }

        if (quadTreeNodes[prevNodeIndex].nextBL == nodeIndex) {
            return quadTreeNodes[prevNodeIndex].nextBR;
        }

        // else quadTreeNodes[prevNodeIndex].nextBR == nodeIndex

        if (prevNodeIndex == 0) {
            // cant step further up than to root
            return 0; // done
        }

        // step up (find next node of parent)
        nodeIndex = prevNodeIndex;
    }
}

// ------------------------------------------------------------------------------------
// Collision Detection
// ------------------------------------------------------------------------------------

// Returns <true> if the entity <index> collision range reaches into the area of node <nodeIndex>
//  Aka it checks whether the entity may potentially have collisions with entities in this node
bool quad_tree_collision_on_node(uint index, uint nodeIndex) {
    float nodeOffsetX = quadTreeNodes[nodeIndex].offsetX;
    float nodeOffsetY = quadTreeNodes[nodeIndex].offsetY;

    vec2 ePos = entities[index].pos;
    vec2 aabbHalfExtents = vec2((quadTreeNodes[nodeIndex].width / 2), (quadTreeNodes[nodeIndex].height / 2));
    vec2 nodeCenter = vec2(nodeOffsetX, nodeOffsetY) + aabbHalfExtents;
    vec2 diff = ePos - nodeCenter;
    vec2 clamped = clamp(diff, vec2(-aabbHalfExtents.x, -aabbHalfExtents.y), aabbHalfExtents);
    vec2 closest = nodeCenter + clamped;

    return quad_tree_in_range(closest, ePos, constants[0].interfaceRange);
}

/**
 * Checks for collisions inside the constants[0].interfaceRange with other entities.
 *  Will invoke the callback 'quad_tree_collision(index, otherIndex)' for every found collision.
 *  Makes sure to avoid duplicates. Every collision is only reported once.
 **/
void quad_tree_check_collisions(uint index) {
    // Ascend and find common parent node
    uint startNodeID = quadTreeEntities[index].nodeIndex; // start at home node
    vec2 AABBmin = vec2(entities[index].pos.x - constants[0].interfaceRange, entities[index].pos.y - constants[0].interfaceRange);
    vec2 AABBmax = vec2(entities[index].pos.x + constants[0].interfaceRange, entities[index].pos.y + constants[0].interfaceRange);
    AABBmin.x = max(AABBmin.x, 0); // clamp AABB to map borders
    AABBmin.y = max(AABBmin.y, 0);
    AABBmax.x = min(AABBmax.x, constants[0].worldSizeX);
    AABBmax.y = min(AABBmax.y, constants[0].worldSizeY);
    while (!quad_tree_is_entity_within_node_AABB(startNodeID, AABBmin, AABBmax)) {
        startNodeID = quadTreeNodes[startNodeID].prevNodeIndex;
    }

    if (quadTreeNodes[startNodeID].first < constants[0].entityCount)
    { // start node is a leaf node => just check and done
        quad_tree_check_entity_collisions_on_node(index, startNodeID);
        return;
    }

    // Descent and test all neighboring nodes
    // At this point we know that startNodeID is an internal node => step down
    uint previousID = quadTreeNodes[startNodeID].nextTL;
    uint nodeID = quadTreeNodes[startNodeID].nextTL;
    while (true)
    {

        if (quadTreeNodes[nodeID].entityCount > 0) {
            // There are entities in this node

            if (quad_tree_collision_on_node(index, nodeID)) {
                // There could be collisions in this node

                if (quadTreeNodes[nodeID].first >= constants[0].entityCount) {
                    // Its am internal node => step down
                    previousID = nodeID;
                    nodeID = quadTreeNodes[nodeID].nextTL;
                    continue;
                } else {
                    // Its a leaf node => check entities
                    quad_tree_check_entity_collisions_on_node(index, nodeID);
                }
            }
        }

        // Advance to next node
        previousID = nodeID;
        nodeID = quadTreeNodes[nodeID].next;

        while (quadTreeNodes[previousID].prevNodeIndex == nodeID) {
            // just stepped up
            if (nodeID == startNodeID) {
                // reached start node
                return; // done
            }
            // keep advancing
            previousID = nodeID;
            nodeID = quadTreeNodes[nodeID].next;
        }
    }
}

// ------------------------------------------------------------------------------------
// Connectivity Detection
// ------------------------------------------------------------------------------------

void collision_list_add(uint index0, uint index1) {
    uint slot = atomicAdd(metadata[0].interfaceCollisionListCount, 1);
    if (slot < constants[0].maxInterfaceCollisionListCount) {
        // Avoid out of bounds memory access
        collisionsList[slot].ID0 = index0; // interfaceID0
        collisionsList[slot].ID1 = index1; // interfaceID1
    }
}

void collision_set_add(uint index0, uint index1) {
    uint index = parameter.interfaceCollisionSetNewOffset + index0; // index determines the block for this entity
    uint slot;
    while(true) {
        slot = collisionsSet[index].offset; // check slot availability in this block
        if (slot < InterfaceCollisionBlockSize)
        { // Free slot available => just add collision entry
            collisionsSet[index].colls[slot] = index1;
            collisionsSet[index].offset++;
            return;
        }
        else if (slot > InterfaceCollisionBlockSize)
        { // This block is full; slot links to next block
            index = parameter.interfaceCollisionSetNewOffset + slot;
        }
        else // (slot == InterfaceCollisionBlockSize)
        { // All slots are full => allocate new ones
            slot = atomicAdd(metadata[0].interfaceCollisionSetCount, 1);
            if (slot < constants[0].maxInterfaceCollisionSetCount) {
                collisionsSet[index].offset = slot; // link old block to new block
                slot += parameter.interfaceCollisionSetNewOffset;
                collisionsSet[slot].colls[0] = index1;
                collisionsSet[slot].offset = 1;
            }
            return;
        }
    }
}

void link_up_event_list_add(uint index0, uint index1) {
    uint slot = atomicAdd(metadata[0].interfaceLinkUpListCount, 1);
    if (slot < constants[0].maxLinkEventCount) {
        // Avoid out of bounds memory access
        linkUpEvents[slot].ID0 = index0; // interfaceID0
        linkUpEvents[slot].ID1 = index1; // interfaceID1
    }
}

void link_down_event_list_add(uint index0, uint index1) {
    uint slot = atomicAdd(metadata[0].interfaceLinkDownListCount, 1);
    if (slot < constants[0].maxLinkEventCount) {
        // Avoid out of bounds memory access
        linkDownEvents[slot].ID0 = index0; // interfaceID0
        linkDownEvents[slot].ID1 = index1; // interfaceID1
    }
}

// Returns true if a collision between 'eID0' and 'eID1' is found in the HashSet at 'colSetOffset', false otherwise
bool find_collision(uint eID0, uint eID1, uint colSetOffset) {
    uint index = colSetOffset + eID0;
    while (true) {
        uint slot = collisionsSet[index].offset;
        for (uint i = 0; i < min(slot, InterfaceCollisionBlockSize); i++)
        { // Iterate all collisions in this block
            uint ID = collisionsSet[index].colls[i];
            if (ID == eID1)
            { // collision found
                return true;
            }
        }
        if (slot <= InterfaceCollisionBlockSize)
        { // no more linked blocks => not found
            return false;
        }
        // else this block links to another
        index = colSetOffset + slot;
    }
}

// Compares the collision detection sets of the previous tick (oldOffset) and
//  the current tick (newOffset) and determines differences.
// no coll -> no coll => still no connection (nothing to do)
//    coll ->    coll => connection still up (nothing to do)
// no coll ->    coll => link went up
//    coll -> no coll => link went down
void detect_connectivity(uint eID) {
    // Detect link up events
    const uint oldOff = parameter.interfaceCollisionSetOldOffset;
    const uint newOff = parameter.interfaceCollisionSetNewOffset;

    // Detect LinkUp events
    uint index = newOff + eID;
    while (true) {
        uint slot = collisionsSet[index].offset;
        for (uint i = 0; i < min(slot, InterfaceCollisionBlockSize); i++)
        { // Iterate all collisions in this block
            uint ID = collisionsSet[index].colls[i];
            if (!find_collision(eID, ID, oldOff))
            { // was not up, but is now up => link came up
                link_up_event_list_add(eID, ID);
            }
        }
        if (slot <= InterfaceCollisionBlockSize)
        { // no more linked blocks
            break;
        }
        // else this block links to another
        index = newOff + slot;
    }

    // Detect LinkDown events
    index = oldOff + eID;
    while (true) {
        uint slot = collisionsSet[index].offset;
        for (uint i = 0; i < min(slot, InterfaceCollisionBlockSize); i++)
        { // Iterate all collisions in this block
            uint ID = collisionsSet[index].colls[i];
            if (!find_collision(eID, ID, newOff))
            { // was up, but is now down => link went down
                link_down_event_list_add(eID, ID);
            }
        }
        if (slot <= InterfaceCollisionBlockSize)
        { // no more linked blocks
            break;
        }
        // else this block links to another
        index = oldOff + slot;
    }
}

// ------------------------------------------------------------------------------------
// Movement Logic
// ------------------------------------------------------------------------------------

// Move entity towards its next waypoint
// Returns the new position (does not change the position!)
vec2 move(uint index) {
    float time = parameter.timeIncrement; // Available time for movement
    vec2 pos = entities[index].pos;

    if (entities[index].targetWaypointOffset >= constants[0].waypointBufferSize) {
        // No waypoints available => stay stationary
        return pos;
    }
    
    uint oldOffset = entities[index].targetWaypointOffset;

    uint waypointIndex = index * constants[0].waypointBufferSize + entities[index].targetWaypointOffset;
    vec2 target = waypoints[waypointIndex].pos;
    float speed = waypoints[waypointIndex].speed;

    float dtt = length(target - pos); // distance to target
    float ttt = dtt / speed; // time to target

    while (time >= ttt) {
        // Entity can move past the next waypoint
        pos = target; // snap to waypoint
        time -= ttt;

        entities[index].targetWaypointOffset++;

        if (entities[index].targetWaypointOffset >= constants[0].waypointBufferSize) {
            // No waypoints available
            // => request more waypoints
            uint slot = atomicAdd(metadata[0].waypointRequestCount, 1);
            if (slot < constants[0].entityCount) { // Avoid out of bounds memory access
                waypointRequests[slot].ID0 = index; // entity ID
                waypointRequests[slot].ID1 = constants[0].waypointBufferSize; // number of requested waypoints
            }

            return pos; // => stay stationary
        }

        // Get next waypoint
        waypointIndex++;
        target = waypoints[waypointIndex].pos;
        speed = waypoints[waypointIndex].speed;
        dtt = length(target - pos);
        ttt = dtt / speed;
    }

    // Move towards the target
    vec2 dir = target - pos;
    float len = length(dir);
    if (len > 0) {
        dir = dir / len; // Normalize
        pos += dir * time;
    }

    // Keep at least waypointBufferThreshold waypoints in buffer
    if (constants[0].waypointBufferSize - oldOffset >= constants[0].waypointBufferThreshold && // only generate one request when falling below threshold
        constants[0].waypointBufferSize - entities[index].targetWaypointOffset < constants[0].waypointBufferThreshold) {
        // Fell below threshold
        // => request more waypoints
        uint slot = atomicAdd(metadata[0].waypointRequestCount, 1);
        if (slot < constants[0].entityCount) { // Avoid out of bounds memory access
            waypointRequests[slot].ID0 = index; // entity ID
            waypointRequests[slot].ID1 = entities[index].targetWaypointOffset; // number of requested waypoints
        }
    }

    return pos;
}

void main() {
    uint index = gl_GlobalInvocationID.x;

    if (index >= constants[0].entityCount) {
        return; // Local group invocation outside of global group size
        // Aka just ignore extra invocations
    }

    uint nodeID;
    uint entityCount;

    switch (parameter.pass) {

    case 0: /* Initialization Pass */
        quad_tree_insert(index, 0 /*start node index*/, 1 /*start node depth*/);
        break;

    case 1: /* Movement Pass */
        vec2 newPos = move(index);
        // Update entity position:
        entities[index].pos = newPos;
        break;

    case 2: /* Collision Detection List Pass */
        // Reset entity color
        entities[index].color = vec4(0, 1, 0, 1);
        // Run collision detection, writing into the list buffer
        quad_tree_check_collisions(index);
        break;

    case 3: /* Collision Detection Set Pass */
        // Reset entity color
        entities[index].color = vec4(0, 1, 0, 1);
        // Reset hashset buffer
        collisionsSet[parameter.interfaceCollisionSetNewOffset + index].offset = 0; // First available slot
        // Run collision detection, writing into the hashset buffer
        quad_tree_check_collisions(index);
        break;

    case 4: /* Connectivity Detection Pass */
        // Reset entity color
        entities[index].color = vec4(0, 1, 0, 1);
        // Reset hashset buffer
        collisionsSet[parameter.interfaceCollisionSetNewOffset + index].offset = 0; // First available slot
        // Run collision detection, writing into the hashset buffer
        quad_tree_check_collisions(index);
        // Run connectivity detection
        detect_connectivity(index);
        break;

    case 5: // Build Quad Tree Init
        // Reset quad tree
        quadTreeEntities[index].next = 0; // reset ourself
        nodeID = quadTreeEntities[index].nodeIndex; // home node
        quadTreeNodes[nodeID].first = constants[0].entityCount;

        // Reset all (parent) node counts
        while (nodeID != 0) {
            quadTreeNodes[nodeID].entityCount = 0;
            nodeID = quadTreeNodes[nodeID].prevNodeIndex;
        }

        quadTreeEntities[index].nodeIndex = 0; // We start at root node

        break;

    case 6: // Build Quad Tree Step
        nodeID = quadTreeEntities[index].nodeIndex;
        entityCount = quadTreeNodes[nodeID].entityCount;
        if (entityCount > constants[0].entityNodeCap) {
            // Too many entities in this node => move to a child node
            float offsetXNext = quadTreeNodes[nodeID].offsetX + (quadTreeNodes[nodeID].width / 2);
            float offsetYNext = quadTreeNodes[nodeID].offsetY + (quadTreeNodes[nodeID].height / 2);
            vec2 ePos = entities[index].pos;

            // All node siblings are next to each other in the buffer:
            // -----------
            // | TL | TR |
            // -----------  -->  [...|TL|TR|BL|BR|...]
            // | BL | BR |
            // -----------
            // => TL+1=TR, TL+2=BL, TL+3=BR, 

            uint right = uint(ePos.x >= offsetXNext);
            uint down = uint(ePos.y < offsetYNext) * 2;
            quadTreeEntities[index].nodeIndex = quadTreeNodes[nodeID].nextTL + right + down;

            nodeID = quadTreeEntities[index].nodeIndex;
            atomicAdd(quadTreeNodes[nodeID].entityCount, 1);
        }
        break;

    case 7: // Build Quad Tree Fini
        nodeID = quadTreeEntities[index].nodeIndex;
        
        // We arrived at our final node => add ourselves to this nodes linked-list
        uint first = quadTreeNodes[nodeID].first;
        do {
            quadTreeEntities[index].next = first;
            first = atomicCompSwap(quadTreeNodes[nodeID].first, quadTreeEntities[index].next, index);
        } while (first != quadTreeEntities[index].next);

        break;
    }

}
